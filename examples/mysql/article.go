// Code generated by ModelQ
// article.go contains model for the database table [blog.article]

package mysql

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/kitekjk/modelq/gmq"
	"strings"
	"time"
)

type Article struct {
	Id         int64     `json:"id"`
	UserId     int64     `json:"user_id"`
	Title      string    `json:"title"`
	State      int       `json:"state"` // 0: published, 1: draft, 2: hidden
	Content    string    `json:"content"`
	Donation   float64   `json:"donation"`
	CreateTime time.Time `json:"create_time"`
	UpdateTime time.Time `json:"update_time"`
}

// Start of the Article APIs.

func (obj Article) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<Article Id=%d>", obj.Id)
	} else {
		return string(data)
	}
}

func (obj Article) Insert(dbtx gmq.DbTx) (Article, error) {
	if result, err := ArticleObjs.Insert(obj).Run(dbtx); err != nil {
		return obj, err
	} else {
		if id, err := result.LastInsertId(); err != nil {
			return obj, err
		} else {
			obj.Id = id
			return obj, err
		}
	}
}

func (obj Article) Update(dbtx gmq.DbTx) (int64, error) {
	fields := []string{"UserId", "Title", "State", "Content", "Donation", "CreateTime"}
	filter := ArticleObjs.FilterId("=", obj.Id)
	if result, err := ArticleObjs.Update(obj, fields...).Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

func (obj Article) Delete(dbtx gmq.DbTx) (int64, error) {
	filter := ArticleObjs.FilterId("=", obj.Id)
	if result, err := ArticleObjs.Delete().Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

// Start of the inner Query Api

type _ArticleQuery struct {
	gmq.Query
}

func (q _ArticleQuery) Where(f gmq.Filter) _ArticleQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _ArticleQuery) OrderBy(by ...string) _ArticleQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := ArticleObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _ArticleQuery) GroupBy(by ...string) _ArticleQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := ArticleObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _ArticleQuery) Limit(offsets ...int64) _ArticleQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _ArticleQuery) Page(number, size int) _ArticleQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _ArticleQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type ArticleRowVisitor func(obj Article) bool

func (q _ArticleQuery) Iterate(dbtx gmq.DbTx, functor ArticleRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := ArticleObjs.toArticle(columns, rb)
		return functor(obj)
	})
}

func (q _ArticleQuery) One(dbtx gmq.DbTx) (Article, error) {
	var obj Article
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = ArticleObjs.toArticle(columns, rb)
		return true
	})
	return obj, err
}

func (q _ArticleQuery) List(dbtx gmq.DbTx) ([]Article, error) {
	result := make([]Article, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := ArticleObjs.toArticle(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

// Start of the model facade Apis.

type _ArticleObjs struct {
	fcMap map[string]string
}

func (o _ArticleObjs) Names() (schema, tbl, alias string) {
	return "blog", "article", "Article"
}

func (o _ArticleObjs) Select(fields ...string) _ArticleQuery {
	q := _ArticleQuery{}
	if len(fields) == 0 {
		fields = []string{"Id", "UserId", "Title", "State", "Content", "Donation", "CreateTime", "UpdateTime"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _ArticleObjs) Insert(obj Article) _ArticleQuery {
	q := _ArticleQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "UserId", "Title", "State", "Content", "Donation"))
	return q
}

func (o _ArticleObjs) Update(obj Article, fields ...string) _ArticleQuery {
	q := _ArticleQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _ArticleObjs) Delete() _ArticleQuery {
	q := _ArticleQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _ArticleObjs) FilterId(op string, p int64, ps ...int64) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("id", op, params...)
}

func (o _ArticleObjs) FilterUserId(op string, p int64, ps ...int64) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("user_id", op, params...)
}

func (o _ArticleObjs) FilterTitle(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("title", op, params...)
}

func (o _ArticleObjs) FilterState(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("state", op, params...)
}

func (o _ArticleObjs) FilterContent(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("content", op, params...)
}

func (o _ArticleObjs) FilterDonation(op string, p float64, ps ...float64) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("donation", op, params...)
}

func (o _ArticleObjs) FilterCreateTime(op string, p time.Time, ps ...time.Time) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("create_time", op, params...)
}

func (o _ArticleObjs) FilterUpdateTime(op string, p time.Time, ps ...time.Time) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("update_time", op, params...)
}

///// Managed Objects Columns definition

func (o _ArticleObjs) ColumnId(p ...int64) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"id", value}
}

func (o _ArticleObjs) ColumnUserId(p ...int64) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"user_id", value}
}

func (o _ArticleObjs) ColumnTitle(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"title", value}
}

func (o _ArticleObjs) ColumnState(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"state", value}
}

func (o _ArticleObjs) ColumnContent(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"content", value}
}

func (o _ArticleObjs) ColumnDonation(p ...float64) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"donation", value}
}

func (o _ArticleObjs) ColumnCreateTime(p ...time.Time) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"create_time", value}
}

func (o _ArticleObjs) ColumnUpdateTime(p ...time.Time) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"update_time", value}
}

////// Internal helper funcs

func (o _ArticleObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _ArticleObjs) toArticle(columns []gmq.Column, rb []sql.RawBytes) Article {
	obj := Article{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "id":
				obj.Id = gmq.AsInt64(rb[i])
			case "user_id":
				obj.UserId = gmq.AsInt64(rb[i])
			case "title":
				obj.Title = gmq.AsString(rb[i])
			case "state":
				obj.State = gmq.AsInt(rb[i])
			case "content":
				obj.Content = gmq.AsString(rb[i])
			case "donation":
				obj.Donation = gmq.AsFloat64(rb[i])
			case "create_time":
				obj.CreateTime = gmq.AsTime(rb[i])
			case "update_time":
				obj.UpdateTime = gmq.AsTime(rb[i])
			}
		}
	}
	return obj
}

func (o _ArticleObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "Id":
			data = append(data, o.ColumnId())
		case "UserId":
			data = append(data, o.ColumnUserId())
		case "Title":
			data = append(data, o.ColumnTitle())
		case "State":
			data = append(data, o.ColumnState())
		case "Content":
			data = append(data, o.ColumnContent())
		case "Donation":
			data = append(data, o.ColumnDonation())
		case "CreateTime":
			data = append(data, o.ColumnCreateTime())
		case "UpdateTime":
			data = append(data, o.ColumnUpdateTime())
		}
	}
	return data
}

func (o _ArticleObjs) columnsWithData(obj Article, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "Id":
			data = append(data, o.ColumnId(obj.Id))
		case "UserId":
			data = append(data, o.ColumnUserId(obj.UserId))
		case "Title":
			data = append(data, o.ColumnTitle(obj.Title))
		case "State":
			data = append(data, o.ColumnState(obj.State))
		case "Content":
			data = append(data, o.ColumnContent(obj.Content))
		case "Donation":
			data = append(data, o.ColumnDonation(obj.Donation))
		case "CreateTime":
			data = append(data, o.ColumnCreateTime(obj.CreateTime))
		case "UpdateTime":
			data = append(data, o.ColumnUpdateTime(obj.UpdateTime))
		}
	}
	return data
}

var ArticleObjs _ArticleObjs

func init() {
	ArticleObjs.fcMap = map[string]string{
		"Id":         "id",
		"UserId":     "user_id",
		"Title":      "title",
		"State":      "state",
		"Content":    "content",
		"Donation":   "donation",
		"CreateTime": "create_time",
		"UpdateTime": "update_time",
	}
	gob.Register(Article{})
}
